克隆羊问题：
克隆羊：根据一个Sheep对象来创建出和当前Sheep属性值一模一样的新Sheep对象
原始方案：根据已有的Sheep对象的getXxx()方法来设置新对象的属性值，从而保证被新创建的对象和原对象属性一样
原始方案优缺点分析：
    优点：1）简单，便于理解
    缺点：1）当Sheep类（即被复制的类）的属性比较多的时候，需要修改的代码多
         2）违背了OCP原则，即当Sheep类中新增了属性是，也需要在Client类中对新属性修改克隆代码

改进方案：
    Object基类中有一个Clone()方法，可以复制出新的类对象。但类需要实现Cloneable接口，实现改接口中的Clone方法。
    上述的这种克隆方案即 原型设计模式

原型设计模式：用原型实例 指定 创建对象的种类，并通过 拷贝这些原型，创建新的对象
            其允许一个对象再创建另一个可制定的对象，而无需要指导如何创建的细节
工作原理：
将一个 原型对象 传给即将 被创建的对象，这个 将被创建的对象 通过 请求 原型对象 来拷贝它(原型对象)的属性 来赋值给自己(将被创建的对象)，即： 对象.clone()

UML图：
    一个类，实现Cloneable接口，重写clone()方法，该类即：原型类


简单的实现clone()方案的分析：
通过实现了Clone()方法后，基本类型能够被复制一份来作为新对象的属性，但是对于引用型属性，老对象和新对象共享（其中一个对象修改了引用
对象的属性，会造成另一个的该属性也会被修改），该现象叫做：浅拷贝
浅拷贝：
1）对数据类型是基本数据类型的成员变量（如Integer、Float），浅拷贝会直接进行值传递，即：将该属性值复制一份给新的对象
2）对数据类型是引用数据类型的成员变量（如ArrayList、自定义类），浅拷贝时进行引用传递，即：将该属性值的引用值（内存地址）复制给新对象。
  实际上两个对象的成员变量都指向同一个引用对象实例。这种情况下，任意一个对象修改引用成员变量时都会造成另一个的成员变量发生改变。
3）浅拷贝默认使用object基类的clone()方法来实现拷贝
    super.clone();
深拷贝：
1）对基本数据类型和引用数据类型的所有成员变量都复制一份新的给新创建的对象
2）为所有引用数据类型的成员变量申请存储空间，并赋值每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。
   即：深拷贝要对整个对象(包括对象的引用类型)进行拷贝
3）实现方式：
   ①重写Object中的clone()方法——复杂程度与引用类型变量的数量有关系，比方式②复杂
   ②同归 序列化与反序列化 进行拷贝——推荐使用该方法



