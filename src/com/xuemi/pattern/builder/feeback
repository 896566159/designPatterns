构造者模式：
典例：JDK中的StringBuilder类
     Appendable 接口定义了多个append方法(抽象方法), 即Appendable 为抽象建
    造者, 定义了抽象方法
     AbstractStringBuilder 实现了 Appendable 接口方法，这里的
    AbstractStringBuilder 已经是建造者，只是不能实例化
     StringBuilder 即充当了指挥者角色，同时充当了具体的建造者，建造方法的
    实现是由 AbstractStringBuilder 完成, 而StringBuilder 继承了
    AbstractStringBuilder

构造者细节和注意事项：
1）客户端（调用者）不知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象
2）每一个具体的构造者都相对独立，用户使用不同的构造者即可得到不同的产品对象
3）可以更加精准的控制产品的创建过程
4）增加新的具体构造这无需修改源码，遵循OCP原则
5）构造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品的差异很大，则不适合使用构造者模式
6）如果产品的内部变化复杂，可能会导致需要重新定义很多具体构造这类来实现这种变化，导致系统变得庞大，因此这种情况下需要慎用构造者模式

抽象工厂模式 VS 构造者模式
1）抽象工厂模式实现对产品家族的创建，一个铲平家族是一系列产品：具有不同分类维度的产品组合，
采用抽象工厂模式不关心构建过程，只关心产品由什么类型的工厂生产即可
2）构造者模式则要求按照指定的流程（构造方法之间有先后顺序）构造产品，它的主要目的是通过组装零配件而产生一个新品。
3）个人理解：抽象工厂的产品和构建过程可能在产品类中已经绑定。
           构造者模式中的产品各组件的组装流程在产品类中未绑定